(function (exports,React) {
  'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  /**
   * Used to define attributes of a table column
   */
  class Column {
  	/**
    * @param {ReactElement|string} header - passed columnKey prop. 
    * If header is a string, it is wrapped in a TH element. 
    * Otherwise, the element is used as the header. 
    * @param {ReactElement} cell - passed rowIndex and columnKey props. 
    * Duplicated for each row.
    * @param {string} columnKey - used as key for the column, 
    * and passed to children
    * @param {string} [align=left] - alignment for the column
    */
  	constructor({ header, cell, columnKey, align = 'left' }) {
  		Object.assign(this, { header, cell, columnKey, align });
  	}
  }

  const has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

  /**
   * A simple javascript utility for conditionally joining classNames together.
   * Slight ES6 adjustments from the fork.
   * @see https://github.com/JedWatson/classnames
   * @alias module:lib/utils.classlist
   */
  function classList(...classes) {
  	let list = [];
  	for (let classname of classes) {
  		if (!classname) continue; //skip falsy values

  		const type = typeof classname;
  		if (type === 'string' || type === 'number') list.push(classname);else if (Array.isArray(classname)) list.push(classList(...classname));else if (type === 'object') {
  			for (let key in classname) if (has(classname, key) && classname[key]) list.push(key);
  		}
  	}
  	return list.join(' ');
  }

  /**
   * Generate unique IDs. Guaranteed to be unique when compared to other strings
   * generated by this function. The strings are complex enough that they 
   * shouldn't be accidentally duplicated by hand.
   * 
   * Math.random should be unqiue because of its seeding algorithm.
   * Convert it to base 36 (numbers + letters), and grab the first 9 characters
   * after the decimal.
   * 
   * @returns {string}
   * @see https://gist.github.com/gordonbrander/2230317
   * @alias module:lib/utils.id
   */
  const id = () => '_' + Math.random().toString(36).substr(2, 9);

  /**
   * Creates an object composed of the own string keyed
   * properties of source that are not set to be omitted.
   * @param {Object} source
   * @param {...string|string[]} props
   * @returns {Object}
   */
  function omit(source = {}, ...props) {
    if (props.length === 0 && Array.isArray(props[0])) props = props[0];

    let target = {};
    for (const key in source) {
      if (!props.includes(key)) target[key] = source[key];
    }
  }

  /**
   * Represents a cell in a table. If the header prop is set to true,
   * then a table header cell will be used instead of a normal table cell.
   */
  const Cell = ({
  	children, header, onClick, align = 'left',
  	colSpan, headers, rowSpan, scope, className, id
  }) => React__default.createElement(header ? 'th' : 'td', {
  	className: classList(className, `align-${ align }`),
  	onClick, colSpan, rowSpan, id,
  	scope: header ? scope : undefined,
  	headers: Array.isArray(headers) ? headers.join(' ') : headers
  }, children);

  Cell.propTypes = {
  	children: React.PropTypes.node,
  	align: React.PropTypes.oneOf(['left', 'center', 'right']),
  	header: React.PropTypes.bool,
  	onClick: React.PropTypes.func,
  	colSpan: React.PropTypes.number,
  	rowSpan: React.PropTypes.number,
  	scope: React.PropTypes.oneOf(['row', 'col', 'rowgroup', 'colgroup', 'auto']),
  	headers: React.PropTypes.oneOfType([React.PropTypes.arrayOf(React.PropTypes.string), React.PropTypes.string]),
  	className: React.PropTypes.string,
  	id: React.PropTypes.string
  };

  /**
   * Used to display a table created via callbacks. The children passed to this
   * element define columns and their data. The cell property of the column
   * is called rowsCount times, and is passed the rowIndex and columnKey.
   */
  const Table = props => {
  	const { columns, rowsCount, rowClassNameGetter } = props;
  	const { rowKeyGetter, onRowClick, onColumnClick } = props;

  	const thead = columns.map(col => {
  		const { header: HeaderContent, columnKey, align } = col;
  		const onClick = onColumnClick ? onColumnClick.bind(undefined, columnKey) : undefined;
  		if (typeof HeaderContent !== 'string') return React__default.createElement(HeaderContent, {
  			columnKey, key: columnKey, align, onClick
  		});else return React__default.createElement(
  			Cell,
  			{ header: true,
  				key: columnKey,
  				align: align,
  				onClick: onClick
  			},
  			HeaderContent
  		);
  	});

  	let rows = [];
  	for (let i = 0; i < rowsCount; i++) {
  		const onClick = onRowClick ? onRowClick.bind(undefined, i) : undefined;
  		rows.push(React__default.createElement(
  			'tr',
  			{ onClick: onClick,
  				className: rowClassNameGetter(i),
  				key: rowKeyGetter(i)
  			},
  			columns.map(({ cell: cellContent, columnKey, align }) => {
  				if (typeof cellContent !== 'string') return React__default.createElement(cellContent, {
  					rowIndex: i, columnKey, key: columnKey, align
  				});else return React__default.createElement(
  					Cell,
  					{ align: align, key: columnKey },
  					cellContent
  				);
  			})
  		));
  	}

  	return React__default.createElement(
  		'table',
  		omit(props, 'columns', 'rowsCount', 'rowClassNameGetter', 'onRowClick'),
  		React__default.createElement(
  			'thead',
  			null,
  			React__default.createElement(
  				'tr',
  				null,
  				thead
  			)
  		),
  		React__default.createElement(
  			'tbody',
  			null,
  			rows
  		)
  	);
  };

  Table.propTypes = {
  	rowsCount: React.PropTypes.number.isRequired,
  	rowClassNameGetter: React.PropTypes.func,
  	rowKeyGetter: React.PropTypes.func,
  	onRowClick: React.PropTypes.func,
  	onColumnClick: React.PropTypes.func,
  	columns: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Column)).isRequired
  };

  Table.defaultProps = {
  	rowClassNameGetter: rowIndex => undefined,
  	rowKeyGetter: rowIndex => `row-${ rowIndex }`
  };

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  const CHECKBOX = id();

  /**
   * Enhances the data table with interactive functionality
   */
  class InteractiveTable extends React.Component {
  	constructor(props) {
  		super(props);

  		this.rowClassHelper = this.rowClassHelper.bind(this);
  		this.rowClickHelper = this.rowClickHelper.bind(this);
  		this.columnClickHelper = this.columnClickHelper.bind(this);
  		this.rowKeyHelper = this.rowKeyHelper.bind(this);
  		this.buildCheckboxesColumn = this.buildCheckboxesColumn.bind(this);

  		const { sorting, selection } = props;
  		let state = {
  			settings: {
  				sort: false,
  				selected: false
  			},
  			sort: {
  				columnKey: undefined,
  				descending: true,
  				ids: new Map()
  			},
  			selected: []
  		};

  		if (sorting) {
  			state.settings.sort = true;

  			if (typeof sorting === 'object' && sorting.columnKey) state.sort.columnKey = sorting.columnKey;
  			/*else {
     	const {data} = props; let firstColumnKey;
     	for (const key in data[0]) {firstColumnKey = key; break;}
     	state.sort.columnKey = firstColumnKey;
     }*/

  			if (typeof sorting === 'object' && sorting.descending) state.sort.descending = sorting.descending;

  			if (typeof sorting === 'object' && sorting.columnKey) state.sort.ids = sortData(props.data, state.sort);else state.sort.ids = sortData(props.data);
  		}

  		if (selection) {
  			state.settings.selected = true;
  			if (Array.isArray(selection)) state.selected = selection;
  		}

  		this.state = state;
  	}

  	render() {
  		console.log(this);
  		const { data } = this.props;
  		const { selected, sort, settings } = this.state,
  		      sLength = selected.length;

  		let columns = [];
  		if (settings.selected) {
  			columns.push(this.buildCheckboxesColumn.call(this));
  		}
  		columns.push(...buildColumns(data, settings.sort ? sort : undefined));

  		return React__default.createElement(
  			'section',
  			{ className: classList('interactive-table', this.props.className) },
  			this.props.children || settings.selected ? React__default.createElement(
  				'header',
  				{ className: 'table-header' },
  				React__default.createElement(
  					'div',
  					{ className: 'table-header-selected',
  						style: {
  							visibility: settings.selected && sLength > 0 ? 'visible' : 'hidden'
  						}
  					},
  					settings.selected ? React__default.createElement(
  						'span',
  						null,
  						sLength,
  						' item',
  						sLength > 1 ? 's' : '',
  						' selected'
  					) : null
  				),
  				React__default.createElement(
  					'div',
  					{ className: 'table-header-main' },
  					this.props.children
  				)
  			) : null,
  			React__default.createElement(Table, {
  				rowsCount: data.length,
  				rowClassNameGetter: this.rowClassHelper,
  				onRowClick: this.rowClickHelper,
  				onColumnClick: this.columnClickHelper,
  				rowKeyGetter: this.rowKeyHelper,
  				columns: columns
  			})
  		);
  	}

  	rowKeyHelper(rowIndex) {
  		const { settings, sort: { ids } } = this.state;
  		if (settings.sort) return ids.get(rowIndex);else return rowIndex;
  	}
  	rowClassHelper(rowIndex) {
  		const { settings, selected } = this.state;
  		if (settings.selected && selected.includes(rowIndex)) return 'checked';
  	}
  	rowClickHelper(rowIndex) {
  		const { selected, settings } = this.state;
  		if (!settings.selected) return;

  		let clone = selected.slice();
  		if (selected.includes(rowIndex)) {
  			clone.splice(clone.indexOf(rowIndex), 1);
  		} else {
  			clone.push(rowIndex);
  		}
  		this.setState({ selected: clone });
  	}

  	columnClickHelper(columnKey) {
  		const { sort, settings } = this.state;

  		if (settings.selected && columnKey === CHECKBOX) {

  			const length = this.props.data.length;
  			const allSelected = this.state.selected.length === length;
  			if (!allSelected) {
  				const oneToNArray = Array.from({ length }, (v, index) => index);
  				this.setState({ selected: oneToNArray });
  			} else {
  				this.setState({ selected: [] });
  			}
  		} else if (settings.sort) {

  			let newState = Object.assign({}, sort);
  			if (sort.columnKey === columnKey) newState.descending = !sort.descending;else {
  				newState.columnKey = columnKey;
  				newState.descending = true;
  			}

  			newState.ids = sortData(this.props.data, newState);
  			this.setState({ sort: newState });
  		}
  	}

  	/**
    * Creates a column for checkboxes
    * @returns {Column}
    */
  	buildCheckboxesColumn() {
  		const rowCount = this.props.data.length,
  		      selectedRows = this.state.selected;
  		const sLength = selectedRows.length;
  		let ids;if (this.state.settings.sort) ids = this.state.sort.ids;
  		const headerRef = checkbox => this._columnCheckbox = checkbox;

  		return new Column({
  			align: 'center', columnKey: CHECKBOX,
  			header(props) {
  				const allChecked = sLength === rowCount;
  				return React__default.createElement(
  					Cell,
  					_extends({}, props, { header: true }),
  					React__default.createElement('input', { type: 'checkbox', checked: allChecked, readOnly: true,
  						ref: headerRef
  					})
  				);
  			},
  			cell({ rowIndex, align }) {
  				const index = ids ? ids.get(rowIndex) : rowIndex;
  				return React__default.createElement(
  					Cell,
  					{ align: align },
  					React__default.createElement('input', { type: 'checkbox', readOnly: true,
  						checked: selectedRows.includes(index)
  					})
  				);
  			}
  		});
  	}

  	componentDidUpdate() {
  		if (!this._columnCheckbox) return;

  		const sLength = this.state.selected.length;
  		const someChecked = sLength > 0 && sLength !== this.props.data.length;
  		if (someChecked) this._columnCheckbox.indeterminate = true;
  	}

  	static get propTypes() {
  		return {
  			selection: React.PropTypes.oneOfType([React.PropTypes.arrayOf(React.PropTypes.int), React.PropTypes.bool]),
  			sorting: React.PropTypes.oneOfType([React.PropTypes.bool, React.PropTypes.shape({ columnKey: React.PropTypes.string }), React.PropTypes.shape({ descending: React.PropTypes.bool }), React.PropTypes.shape({
  				columnKey: React.PropTypes.string,
  				descending: React.PropTypes.bool
  			})]),

  			data: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,

  			className: React.PropTypes.string,
  			children: React.PropTypes.node
  		};
  	}
  }

  /**
   * Sorts an array of objects using the provided info
   * @param {Object[]} data to sort
   * @param {string} opts.columnKey - values at this key are used for sorting
   * @param {boolean} [opts.descending=true] if false, reverse the sorted array
   * @returns {Map} getting a rowIndex returns the new index
   */
  function sortData(data = [], { columnKey, descending = true } = {}) {
  	if (columnKey == null) {
  		const simple = new Map();
  		for (const index of data.keys()) simple.set(index, index);
  		return simple;
  	}

  	const type = typeof data[0][columnKey];
  	let compareFunc;
  	if (type === 'number') compareFunc = (a, b) => a - b;else compareFunc = (a, b) => a.localeCompare(b);

  	const sorted = data.map((value, index) => ({ value, index })).sort((aObject, bObject) => {
  		const a = aObject.value[columnKey],
  		      b = bObject.value[columnKey];
  		return compareFunc(a, b);
  	});
  	if (!descending) sorted.reverse();

  	const result = new Map();
  	for (const [index, { index: oldIndex }] of sorted.entries()) result.set(oldIndex, index);
  	console.log(result);
  	return result;
  }

  /**
   * @param {Object[]} data
   * @param {Object} [sortInfo]
   * @param {string} [sortInfo.columnKey]
   * @param {boolean} [sortInfo.descending=true]
   * @param {Object} [schema]
   * @param {Object} [tooltips]
   * @returns {Iterable<Column>}
   */
  function* buildColumns(data, sortInfo, schema = data[0], tooltips = {}) {
  	const sortKey = sortInfo ? sortInfo.columnKey : undefined;

  	for (const columnKey in schema) {
  		let align = 'left';const type = typeof schema[columnKey];
  		if (type == 'number') align = 'right';else if (type == 'boolean') align = 'center';

  		const thisSorting = sortKey === columnKey;

  		let sortIcon = null;
  		if (sortInfo) {
  			if (thisSorting) {
  				const { descending = true } = sortInfo;
  				sortIcon = React__default.createElement(
  					'i',
  					{ className: 'material-icons md-18 table-sort-icon sort-active' },
  					descending ? 'arrow_downward' : 'arrow_upward'
  				);
  			} else {
  				sortIcon = React__default.createElement(
  					'i',
  					{ className: 'material-icons md-18 table-sort-icon' },
  					'arrow_downward'
  				);
  			}
  		}

  		yield new Column({
  			columnKey, align,
  			header: ({ align, onClick, columnKey }) => React__default.createElement(
  				Cell,
  				{ header: true, align: align, onClick: onClick, className: 'th-hoverable' },
  				React__default.createElement(
  					'span',
  					{ key: 'normal',
  						className: classList('table-cell-normal', { 'hidden': thisSorting })
  					},
  					columnKey,
  					align === 'left' ? React__default.createElement('span', { style: { width: 18 } }) : null
  				),
  				React__default.createElement(
  					'span',
  					{ key: 'hover', title: tooltips[columnKey], hidden: true,
  						className: classList('table-cell-hover', `align-${ align }`, { 'visible': thisSorting })
  					},
  					align !== 'left' ? sortIcon : null,
  					columnKey,
  					align === 'left' ? sortIcon : null
  				)
  			),
  			cell({ rowIndex, columnKey }) {
  				const index = sortInfo ? sortInfo.ids.get(rowIndex) : rowIndex;
  				return React__default.createElement(
  					Cell,
  					null,
  					data[index][columnKey]
  				);
  			}
  		});
  	}
  }

  exports.Table = Table;
  exports.Column = Column;
  exports.Cell = Cell;
  exports.InteractiveTable = InteractiveTable;

}((this.T = this.T || {}),React));
//# sourceMappingURL=bundle.js.map
