(function (exports,React) {
  'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  /**
   * Used to define attributes of a table column
   */
  class Column {
  	/**
    * @param {ReactElement|string} header - passed columnKey prop. 
    * If header is a string, it is wrapped in a TH element. 
    * Otherwise, the element is used as the header. 
    * @param {ReactElement} cell - passed rowIndex and columnKey props. 
    * Duplicated for each row.
    * @param {string} columnKey - used as key for the column, 
    * and passed to children
    * @param {string} [align=left] - alignment for the column
    */
  	constructor({ header, cell, columnKey, align = 'left' }) {
  		Object.assign(this, { header, cell, columnKey, align });
  	}
  }

  const Row = ({ onClick, className, columns, rowIndex }) => React__default.createElement(
  	'tr',
  	{ onClick: onClick, className: className },
  	columns.map(({ cell: cellContent, columnKey, align }) => React__default.createElement(cellContent, { rowIndex, columnKey, align, key: columnKey }))
  );

  Row.propTypes = {
  	onClick: React.PropTypes.func,
  	className: React.PropTypes.string,
  	columns: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Column)).isRequired,
  	rowIndex: React.PropTypes.number.isRequired
  };

  const has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);

  /**
   * A simple javascript utility for conditionally joining classNames together.
   * Slight ES6 adjustments from the fork.
   * @see https://github.com/JedWatson/classnames
   * @alias module:lib/utils.classlist
   */
  function classList(...classes) {
  	let list = [];
  	for (let classname of classes) {
  		if (!classname) continue; //skip falsy values

  		const type = typeof classname;
  		if (type === 'string' || type === 'number') list.push(classname);else if (Array.isArray(classname)) list.push(classList(...classname));else if (type === 'object') {
  			for (let key in classname) if (has(classname, key) && classname[key]) list.push(key);
  		}
  	}
  	return list.join(' ');
  }

  /**
   * Generate unique IDs. Guaranteed to be unique when compared to other strings
   * generated by this function. The strings are complex enough that they 
   * shouldn't be accidentally duplicated by hand.
   * 
   * Math.random should be unqiue because of its seeding algorithm.
   * Convert it to base 36 (numbers + letters), and grab the first 9 characters
   * after the decimal.
   * 
   * @returns {string}
   * @see https://gist.github.com/gordonbrander/2230317
   * @alias module:lib/utils.id
   */
  const id = () => '_' + Math.random().toString(36).substr(2, 9);

  /**
   * Creates an object composed of the own string keyed
   * properties of source that are not set to be omitted.
   * @param {Object} source
   * @param {...string|string[]} props
   * @returns {Object}
   */
  function omit(source = {}, ...props) {
    if (props.length === 0 && Array.isArray(props[0])) props = props[0];

    let target = {};
    for (const key in source) {
      if (!props.includes(key)) target[key] = source[key];
    }
  }

  /**
   * Formats a camelCase string into a string with normal casing and spaces.
   * @param {string} string
   * @returns {string}
   * @example
   * format('camelCaseText') //returns Camel Case Text
   */
  function format(string) {
    if (typeof string === 'undefined') return undefined;
    const spaced = string.replace(/[A-Z]/g, match => ` ${ match }`);
    return spaced.charAt(0).toUpperCase() + spaced.substr(1);
  }

  /**
   * Used to display a table created via callbacks. The children passed to this
   * element define columns and their data. The cell property of the column
   * is called rowsCount times, and is passed the rowIndex and columnKey.
   */
  const Table = props => {
  	const { columns, rowsCount, rowClassNameGetter } = props;
  	const { rowKeyGetter, onRowClick, onColumnClick } = props;

  	const thead = columns.map(col => {
  		const { header: HeaderContent, columnKey, align } = col;
  		const onClick = onColumnClick ? onColumnClick.bind(undefined, columnKey) : undefined;
  		return React__default.createElement(HeaderContent, {
  			columnKey, align, onClick, key: columnKey
  		});
  	});

  	let rows = [];
  	for (let i = 0; i < rowsCount; i++) {
  		const onClick = onRowClick ? onRowClick.bind(undefined, i) : undefined;
  		rows.push(React__default.createElement(Row, { onClick: onClick,
  			columns: columns,
  			className: rowClassNameGetter(i),
  			key: rowKeyGetter(i),
  			rowIndex: i
  		}));
  	}

  	return React__default.createElement(
  		'table',
  		omit(props, 'columns', 'rowsCount', 'rowClassNameGetter', 'onRowClick'),
  		React__default.createElement(
  			'thead',
  			null,
  			React__default.createElement(
  				'tr',
  				{ className: 'table-th-row' },
  				thead
  			)
  		),
  		React__default.createElement(
  			'tbody',
  			null,
  			rows
  		),
  		props.children
  	);
  };

  Table.propTypes = {
  	rowsCount: React.PropTypes.number.isRequired,
  	rowClassNameGetter: React.PropTypes.func,
  	rowKeyGetter: React.PropTypes.func,
  	onRowClick: React.PropTypes.func,
  	onColumnClick: React.PropTypes.func,
  	columns: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Column)).isRequired,
  	children: React.PropTypes.node //should be a tfoot
  };

  Table.defaultProps = {
  	rowClassNameGetter: rowIndex => undefined,
  	rowKeyGetter: rowIndex => `row-${ rowIndex }`
  };

  /**
   * Represents a cell in a table. If the header prop is set to true,
   * then a table header cell will be used instead of a normal table cell.
   */
  const Cell = ({
  	children, header, onClick, align = 'left',
  	colSpan, headers, rowSpan, scope, className, id
  }) => React__default.createElement(header ? 'th' : 'td', {
  	className: classList(className, `align-${ align }`),
  	onClick, colSpan, rowSpan, id,
  	scope: header ? scope : undefined,
  	headers: Array.isArray(headers) ? headers.join(' ') : headers
  }, children);

  Cell.propTypes = {
  	children: React.PropTypes.node,
  	align: React.PropTypes.oneOf(['left', 'center', 'right']),
  	header: React.PropTypes.bool,
  	onClick: React.PropTypes.func,
  	colSpan: React.PropTypes.number,
  	rowSpan: React.PropTypes.number,
  	scope: React.PropTypes.oneOf(['row', 'col', 'rowgroup', 'colgroup', 'auto']),
  	headers: React.PropTypes.oneOfType([React.PropTypes.arrayOf(React.PropTypes.string), React.PropTypes.string]),
  	className: React.PropTypes.string,
  	id: React.PropTypes.string
  };

  /**
   * Sorts an array of objects using the provided info, then returns a map
   * where the keys correspond to the old index and the values correspond to the 
   * new index.
   * @param {Object[]} data to sort
   * @param {string} [opts.columnKey] - values at this key are used for sorting.
   * If there is no column specified, a map where the values are identical to the 
   * keys will be returned.
   * @param {boolean} [opts.descending=true] if false, reverse the sorted array
   * @returns {Map} getting a rowIndex returns the new index
   */
  function sortMap(data = [], { columnKey, descending = true } = {}) {
  	if (columnKey == null) {
  		const simple = new Map();
  		for (const index of data.keys()) simple.set(index, index);
  		return simple;
  	}

  	const type = typeof data[0][columnKey];
  	let compareFunc;
  	if (type === 'number') compareFunc = (a, b) => a - b;else compareFunc = (a, b) => a.localeCompare(b);

  	const sorted = data.map((value, index) => ({ value, index })).sort((aObject, bObject) => {
  		const a = aObject.value[columnKey],
  		      b = bObject.value[columnKey];
  		return compareFunc(a, b);
  	});
  	if (!descending) sorted.reverse();

  	const result = new Map();
  	for (const [index, { index: oldIndex }] of sorted.entries()) result.set(oldIndex, index);
  	return result;
  }

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  const CHECKBOX = id();

  /**
   * Enhances the data table with interactive functionality
   */
  class InteractiveTable extends React.Component {
  	constructor(props) {
  		super(props);

  		this.rowClassHelper = this.rowClassHelper.bind(this);
  		this.rowClickHelper = this.rowClickHelper.bind(this);
  		this.columnClickHelper = this.columnClickHelper.bind(this);
  		this.rowKeyHelper = this.rowKeyHelper.bind(this);

  		const { sorting, selection } = props;
  		let state = {
  			settings: {
  				sort: false,
  				selected: false
  			},
  			sort: {
  				columnKey: undefined,
  				descending: true,
  				ids: new Map()
  			},
  			selected: []
  		};

  		if (sorting) {
  			state.settings.sort = true;

  			if (typeof sorting === 'object') state.sort = Object.assign(state.sort, sorting);

  			state.sort.ids = sortMap(props.data, state.sort);
  		}

  		if (selection) {
  			state.settings.selected = true;
  			if (Array.isArray(selection)) state.selected = selection;
  		}

  		this.state = state;
  	}

  	/**
    * @type {Map<string, string>} a map where the keys correspond to results from
    * typeof, and the values correspond to possible alignments for a table cell.
    * @example
    * this.alignmentMap.get(typeof 0) // returns 'right'
    * @abstract
    */
  	get alignmentMap() {
  		return new Map([['number', 'right'], ['boolean', 'center']]);
  	}

  	/**
    * @param {number} amountSelected - amount of selected rows
    * @returns {ReactElement} an element used to indicate how many rows 
    * are selected to the user.
    */
  	selectedHeading(amountSelected) {
  		const plural = amountSelected > 1;
  		return React__default.createElement(
  			'span',
  			null,
  			amountSelected,
  			' item',
  			plural ? 's' : '',
  			' selected'
  		);
  	}
  	/** @abstract @returns {Column[]} columns appended to the table */
  	extraColumns() {
  		return [];
  	}
  	/** @abstract @returns {ReactElement} a heading for the table */
  	heading() {
  		return null;
  	}
  	/** @abstract @returns {ReactElement} a tfoot element used in the table */
  	tfoot() {
  		return null;
  	}
  	/** @abstract @returns {ReactElement} a footer for the table */
  	footer() {
  		return null;
  	}

  	/**
    * The header cell for each column. Called when building columns.
    * @param {string} title
    * @param {string} [definition] - tooltip text 
    * @param {boolean} active
    * @param {boolean} sortDown
    * @param {Object} props
    * @param {string} props.align - used to align the cell left/center/right
    * @param {function} props.onClick
    * @param {ReactElement} props.children - meant to be the sorting icon
    * @returns {ReactElement} 
    */
  	columnHeader(title, definition, active, sortDown, { align, onClick }) {
  		return React__default.createElement(
  			Cell,
  			{ header: true,
  				className: 'th-hoverable',
  				align: align, onClick: onClick
  			},
  			React__default.createElement(
  				'span',
  				{ className: classList('table-cell-normal', { 'hidden': active }) },
  				title
  			),
  			React__default.createElement(
  				'span',
  				{
  					className: classList('table-cell-hover', `align-${ align }`, { 'visible': active }), title: definition
  				},
  				align !== 'left' ? this.sortingIcon(active, sortDown) : null,
  				title,
  				align === 'left' ? this.sortingIcon(active, sortDown) : null
  			)
  		);
  	}

  	/**
    * The sorting icon used in the header cells. Returns null if sorting is 
    * disabled.
    * @param {boolean} active - darkens the icon to indicate the cell is selected
    * @param {boolean} downard - displays a down arrow if true, up arrow if false
    */
  	sortingIcon(active, downward) {
  		if (!this.state.settings.sort) return null;
  		return React__default.createElement('i', { className: classList('material-icons md-18', 'table-sort-icon', { 'sort-active': active }),
  			children: downward ? 'arrow_downward' : 'arrow_upward'
  		});
  	}

  	/**
    * Iterates through the keys of the data object to create columns
    * @returns {Iterable<Column>}
    */
  	*buildColumns() {
  		const { data, tooltips = new Map(), cell = Cell, schema = data[0] } = this.props;
  		const sortFlag = this.state.settings.sort;
  		const { columnKey: sortKey, descending, ids } = this.state.sort;

  		for (const columnKey in schema) {
  			yield new Column({
  				columnKey, align: this.alignmentMap.get(detectType(schema[columnKey])),
  				header: props => {
  					const active = sortKey === columnKey;
  					const {
  						title = format(columnKey), definition
  					} = tooltips.get(columnKey) || {};
  					return this.columnHeader(title, definition, active, descending, props);
  				},
  				cell(props) {
  					const { rowIndex } = props;
  					const index = sortFlag ? ids.get(rowIndex) : rowIndex;
  					props = Object.assign({}, props, { rowIndex: index });

  					let child = data[index][columnKey];
  					if (!React.isValidElement(child) && child != null) child = String(child);

  					return React__default.createElement(cell, props, child);
  				}
  			});
  		}
  	}

  	render() {
  		const { data } = this.props;
  		const { selected, sort, settings } = this.state,
  		      sLength = selected.length;

  		let columns = [];
  		if (settings.selected) columns.push(this.buildCheckboxesColumn());

  		columns.push(...this.buildColumns());

  		if (settings.sort) {
  			columns.push(...this.extraColumns().map(c => {
  				let col = new Column(c);
  				col.cell = props => c.cell(Object.assign({}, props, {
  					rowIndex: settings.sort ? sort.ids.get(props.rowIndex) : props.rowIndex
  				}));
  				return col;
  			}));
  		} else columns.push(...this.extraColumns());

  		return React__default.createElement(
  			'section',
  			{ className: classList('interactive-table', this.props.className) },
  			settings.selected ? React__default.createElement(
  				'header',
  				{ className: 'table-header' },
  				React__default.createElement(
  					'div',
  					{ className: 'table-header-selected',
  						style: {
  							visibility: settings.selected && sLength > 0 ? 'visible' : 'hidden'
  						}
  					},
  					settings.selected ? this.selectedHeading(sLength) : null
  				),
  				React__default.createElement(
  					'div',
  					{ className: 'table-header-main' },
  					this.heading()
  				)
  			) : null,
  			React__default.createElement(Table, {
  				rowsCount: data.length,
  				rowClassNameGetter: this.rowClassHelper,
  				onRowClick: this.rowClickHelper,
  				onColumnClick: this.columnClickHelper,
  				rowKeyGetter: this.rowKeyHelper,
  				columns: columns,
  				children: this.tfoot()
  			}),
  			this.footer()
  		);
  	}

  	rowKeyHelper(rowIndex) {
  		const { settings, sort: { ids } } = this.state;
  		if (settings.sort) return ids.get(rowIndex);else return rowIndex;
  	}
  	rowClassHelper(rowIndex) {
  		const { settings, selected } = this.state;
  		if (settings.selected && selected.includes(rowIndex)) return 'checked';
  	}
  	rowClickHelper(rowIndex) {
  		const { selected, settings } = this.state;
  		if (!settings.selected) return;

  		let clone = selected.slice();
  		if (selected.includes(rowIndex)) {
  			clone.splice(clone.indexOf(rowIndex), 1);
  		} else {
  			clone.push(rowIndex);
  		}
  		this.setState({ selected: clone });
  	}

  	columnClickHelper(columnKey) {
  		const { sort, settings } = this.state;

  		if (settings.selected && columnKey === CHECKBOX) {

  			const length = this.props.data.length;
  			const allSelected = this.state.selected.length === length;
  			if (!allSelected) {
  				const oneToNArray = Array.from({ length }, (v, index) => index);
  				this.setState({ selected: oneToNArray });
  			} else {
  				this.setState({ selected: [] });
  			}
  		} else if (settings.sort) {

  			let newState = Object.assign({}, sort);
  			if (sort.columnKey === columnKey) newState.descending = !sort.descending;else {
  				newState.columnKey = columnKey;
  				newState.descending = true;
  			}

  			newState.ids = sortMap(this.props.data, newState);
  			this.setState({ sort: newState });
  		}
  	}

  	/**
    * Creates a column for checkboxes
    * @returns {Column}
    */
  	buildCheckboxesColumn() {
  		const rowCount = this.props.data.length,
  		      selectedRows = this.state.selected;
  		const sLength = selectedRows.length;
  		let ids;if (this.state.settings.sort) ids = this.state.sort.ids;
  		const headerRef = checkbox => this._columnCheckbox = checkbox;

  		return new Column({
  			align: 'center', columnKey: CHECKBOX,
  			header(props) {
  				const allChecked = sLength === rowCount;
  				return React__default.createElement(
  					Cell,
  					_extends({}, props, { header: true }),
  					React__default.createElement('input', { type: 'checkbox', checked: allChecked, readOnly: true,
  						ref: headerRef
  					})
  				);
  			},
  			cell({ rowIndex, align }) {
  				const index = ids ? ids.get(rowIndex) : rowIndex;
  				return React__default.createElement(
  					Cell,
  					{ align: align },
  					React__default.createElement('input', { type: 'checkbox', readOnly: true,
  						checked: selectedRows.includes(index)
  					})
  				);
  			}
  		});
  	}

  	componentDidUpdate() {
  		if (!this._columnCheckbox) return;

  		const sLength = this.state.selected.length;
  		const someChecked = sLength > 0 && sLength !== this.props.data.length;
  		if (someChecked) this._columnCheckbox.indeterminate = true;
  	}

  	static get propTypes() {
  		return {
  			selection: React.PropTypes.oneOfType([React.PropTypes.arrayOf(React.PropTypes.int), React.PropTypes.bool]),
  			sorting: React.PropTypes.oneOfType([React.PropTypes.bool, React.PropTypes.shape({ columnKey: React.PropTypes.string }), React.PropTypes.shape({ descending: React.PropTypes.bool }), React.PropTypes.shape({
  				columnKey: React.PropTypes.string,
  				descending: React.PropTypes.bool
  			})]),

  			data: React.PropTypes.arrayOf(React.PropTypes.object).isRequired,
  			schema: React.PropTypes.object,
  			tooltips: React.PropTypes.instanceOf(Map),
  			cell: React.PropTypes.node,
  			extraColumns: React.PropTypes.arrayOf(React.PropTypes.instanceOf(Column)),

  			className: React.PropTypes.string,
  			children: React.PropTypes.node
  		};
  	}
  }

  /**
   * Returns either the typeof an object or the type listed there.
   * @param {string|any} typeSchema - if a string that corresponds to a result
   * from 'typeof', typeSchema is returned. Otherwise, the type of typeSchema is
   * returned.
   */
  function detectType(typeSchema) {
  	const type = typeof typeSchema;
  	if (type !== 'string') return type;
  	const typeofRegExp = /^(boolean|number|string|symbol|undefined|object|function)$/;
  	if (typeofRegExp.test(typeSchema)) return typeSchema;else return type;
  }

  exports.Column = Column;
  exports.Cell = Cell;
  exports['default'] = InteractiveTable;

}((this.T = this.T || {}),React));
//# sourceMappingURL=bundle.js.map
