/**
 * @module lib/utils
 */

/**
 * Checks if the document has a non-loading readystate, and resolves
 * once it does/changes to be ready.
 * @param {Document} document
 * @returns {Promise} resolves when ready
 */
const isReady = exports.isReady = document => new Promise(resolve => {
	const checkState = () => {if (document.readyState != 'loading') resolve()}
	document.addEventListener('readystatechange', checkState);
	checkState();
});

/**
 * Resolves when the DOM is ready to interact with
 * @type {Promise<void>}
 * @author Jake Archibald
 * @see {@link https://github.com/jakearchibald/offline-wikipedia}
 * @requires document
 */
exports.domready = typeof document === 'undefined' ? null : isReady(document);

const has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
/**
 * Fork of https://github.com/JedWatson/classnames/blob/master/index.js
 * Slight ES6 adjustments
 */
const classList = exports.classlist = function(...classes) {
	let list = [];
	for (let classname of classes) {
		if (!classname) continue; //skip falsy values
		
		const type = typeof classname;
		if (type === 'string' || type === 'number') 
			list.push(classname);
		else if (Array.isArray(classname)) 
			list.push( classList(...classname) );
		else if (type === 'object') {
			for (let key in classname) 
				if (has(classname, key) && classname[key]) list.push(key);
		}
	}
	return list.join(' ');
}

/**
 * Generate unique IDs. Guaranteed to be unique when compared to other strings
 * generated by this function. The strings are complex enough that they 
 * shouldn't be accidentally duplicated by hand.
 * 
 * Math.random should be unqiue because of its seeding algorithm.
 * Convert it to base 36 (numbers + letters), and grab the first 9 characters
 * after the decimal.
 * 
 * @returns {string}
 * @see https://gist.github.com/gordonbrander/2230317
 */
exports.id = () => '_' + Math.random().toString(36).substr(2, 9);

/** @type {symbol} Indicates a removed key */
const REMOVED = exports.REMOVED = Symbol('REMOVED');

/**
 * Returns an object only containing properties that have changed between
 * the two given objects.
 * @param {Object} oldStore
 * @param {Object} newStore
 * @returns {Object[]} an object with only updated keys. Removed keys are
 * given a value of the REMOVED Symbol.
 */
exports.diff = function(oldStore, newStore) {
	if (oldStore === newStore) return undefined;
	if (typeof newStore !== typeof oldStore) return newStore;
	else if (Array.isArray(newStore)) {
		let clone = [...newStore];
		return oldStore.reduce((difference, oldValue) => {
			const newIndex = clone.indexOf(oldValue);
			if (newIndex === -1) difference.push(REMOVED);
			else {
				const subdiff = diff(oldValue, clone[newIndex]);
				difference.push(subdiff);
				clone.splice(newIndex, 1); 
			}
			return difference;
		}, []).concat(clone);
	} else if (typeof newStore == 'object' && newStore !== null) {
		let oldKeys = Object.keys(oldStore);
		let difference = {};
		for (let newKey in newStore) {
			if (!has(oldStore, newKey)) difference[newKey] = newStore[newKey];
			else {
				const subdiff = diff(oldStore[newKey], newStore[newKey]);
				if (subdiff !== undefined) difference[newKey] = subdiff;
				oldKeys.splice(oldKeys.indexOf(newKey), 1);
			}
		}
		for (let removedKey of oldKeys) difference[removedKey] = REMOVED;
		return difference;
	} else return newStore;
}

/**
 * Transforms an array of objects into a keyed map, using the specified
 * key property as the key used in the Map.
 * @param {Array<Object>} array
 * @param {string} idKey
 * @returns {Map<string, Object>}
 */
exports.arrayToMap = (array, idKey) => array.reduce(
	(map, obj) => map.set(obj[idKey], obj), new Map()
);

/**
 * Transforms an array of objects into a keyed object, using the specified
 * key property as the key used in the new object.
 * @param {Array<Object>} array
 * @param {string} idKey
 * @returns {Object}
 */
exports.arrayToObjectMap = (array, idKey) => array.reduce((newObj, obj) => {
	newObj[ obj[idKey] ] = obj; return newObj;
}, {})

/**
 * A function that can be used as the 'default value' of a parameter to quickly
 * throw TypeErrors for required parameters
 * @param {string} [message] - appends extra text to the error message.
 * @throws {TypeError} 
 * @example
 * function foo(bar = required()) {
 *   //code that needs bar
 * }
 * 
 * foo() //TypeError: Missing required function parameter
 * @example
 * function hello(target = required('target')) {
 *   return 'Hello ' + target;
 * }
 * hello() //TypeError: Missing required function parameter target
 */
exports.required = function(message) {
	const append = message ? ` ${message}` : '';
	throw TypeError('Missing required function parameter' + append);
}